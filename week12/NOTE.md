# 每周总结可以写在这里

## 简单 wildcard 实现

wildcard 要求整个字符串和 pattern 完全匹配，而不是部分匹配

思路：

1. 计算 pattern 有多少\*
2. 如果没有\*，
    1. 变成直接匹配
3. 如果有\*
    1. 匹配第一个\*之前的部分，如果不匹配，返回 false
    2. 对最后一个\*之前的部分进行匹配
    3. 对每个\*的后面部分进行匹配，此处使用正则匹配，因为后面部分可能包含?
        1. 将?替换成[\s\S]匹配，如果匹配不到，返回 false
    4. 对最后一个\*之后的部分匹配，如果不匹配，返回 false
    5. 返回 true

## kmp

kmp 是找出 source 中是否包含 pattern 字符串

思路：
kmp算法分为两部分
1. 计算pattern中每个位置不匹配时应该回退到哪个位置的数组(或者不应该叫数组？)
   -- 似乎很简单，不太好写
2. 遍历匹配
   1. 从字符串的起始位置和pattern的起始位置开始匹配
      1. 如果不匹配，字符串位置+1，继续匹配
      2. 如果匹配到了，则pattern位置+1，继续匹配
   2. 如果pattern匹配完了，return true
   3. 如果匹配失败，且pattern的匹配位置>1
   4. 字符串的匹配位置-1，pattern的匹配位置回退到第一部分中算出来的数组的位置

## trie

字典树将字符串拆分成一个个字符存储，有以下优点
1. 可以轻松的找到最大的字符串和最小的字符串
2. 如果字符串很多，但重复度很高，可以节省存储空间

字典树的方法根据使用情况而定，只有插入方法是比较固定的

插入方法：
1. 定义一个根节点，是一个空对象
2. 将需要插入的字符串拆分成n个字符，循环遍历这些字符
3. 如果没有字符属性，将字符属性设置为空对象，
4. 将该属性作为节点，处理下一个字符
5. 处理完成所有字符后，在最后一个节点上将字符次数+1

## ll
